# this course
I decided to take the Introduction to DevOps for several reasons. First, I had heard about DevOps from colleagues, so the topic was a bit unknown to me. I never found a course that interested me or was the right time, right place until now when I got a recommendation from my study advisor at Metropolia.

At work, we use Agile and Azure DevOps, so to become a Product Owner I thought the course would give me a good introduction to what is DevOps. For example, I had no idea DevOps was a way of thinking and doing things to improve the deliverability and quality of software. I thought, probably like a few other people, that it was a set of tools. I also thought I would have to read and watch a lot of content and peer review other people’s work.

I was looking for something simple, so the course description, material and learning outcomes checked those boxes. I did expect there to be some technical issues since I sometimes struggle with having the right computer and OS to complete assignments.

I am open to trying new learning sites, so I decided to give FiTech a chance. While looking through the course list I noticed I did have not a lot of time to enroll in this course and the course was starting soon, so that was a reason for taking the course. It just so happened that it fit in nicely with my work and study schedules since I have not been able to attend a face-to-face course at Metropolia for over two years.

# learned
One thing I learned during the course was destructive testing. Having done software testing and reported bugs for years, the concept of testing the reliability of software immediately clicked with me. I wouldn’t go so far as to pour water into servers, but a little chaos can do the world some good.

It was interesting to learn how some companies encourage destructive testing and schedule game days. I found the concept of a game day very helpful because it not only gets people face-to-face but encourages group work and discussions on how to fix potential problems.

Sometimes a test suite or plan will have someone do very specific things with the software. That is, alright and needed for repetition as well as quality assurance. But what about going one step further? What are the unknowns? How reliable is this or that service? These questions and others are fascinating to me. Sometimes the smallest commit or something perceived as a simple thing to add to the software can break the entire thing. Knowing what those things are and keeping track of them means you can use them to test and automate things for continuous delivery.

In the end, I think I enjoy the creativity that comes with destructive testing and the reassurance that known bugs and problems can be found internally before deploying the software.

In terms of the most or least challenging topic of the course, I found the configuration management topic most challenging since I did not have a machine to try out SaltStack. I would have also liked to try out Vagrant, Serverspec and Graphite. Using Git was the easiest challenge since I was already familiar with GitHub and Atom.
