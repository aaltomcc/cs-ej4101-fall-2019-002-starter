# this course
I decided to take the **Introduction to DevOps** course for several reasons. First, I had heard about DevOps from colleagues, but the topic was a bit unknown to me. I never found a course that interested me or was the right time, right place until now when I got a recommendation from my study advisor at Metropolia.

To become a better Product Owner at work, I thought this course would give me a good introduction to what is DevOps. For example, I had no idea DevOps was a way of thinking and doing things to improve the deliverability and quality of software. I thought, probably like a few other people, that it was a set of tools. I also thought I would have to read and watch a lot of content and peer review other people’s work.

I was looking for something simple, so the course description, material and learning outcomes checked those boxes. I did expect there to be some technical issues since I sometimes struggle with having the right computer and OS to complete assignments.

I do like trying new learning sites, so I decided to give FiTech a chance. While looking through the course list I noticed I did have not a lot of time to enroll in this course and the course was starting soon, so those were other reasons for taking the course. It just so happened that the course fit in nicely with my work and study schedules since I have not been able to attend a face-to-face course at Metropolia for over two years.

# learned
One thing I learned during the course was destructive testing. Having done software testing and reported bugs for years, the concept of testing the reliability of software immediately clicked with me. I wouldn’t go so far as to pour water into servers, but a little chaos can do the world some good.

It was interesting to learn how some companies encourage destructive testing and schedule game days. I found the concept of a game day very helpful because it not only gets people face-to-face but encourages group work and discussions on how to fix problems and do things better.

Sometimes a test suite or plan will have someone do very specific things with the software. That is needed for repetition as well as quality assurance. But what about going one step further? What are the unknowns? How reliable is this or that service? What happens if I do this instead of that? These questions and others are fascinating to me. Sometimes the smallest commit or something perceived as a simple thing to add to the software can break the entire thing. Knowing what those things are and keeping track of them means you can use them to test and automate things for future deliveries.

In the end, I think I enjoy the creativity that comes with destructive testing and the reassurance that known bugs and problems can be found internally before they reach customers.

As for most or least challenging topics of the course, I found the configuration management topic difficult since I did not have a machine to try out SaltStack. I would have also liked to try out Vagrant, Serverspec and Graphite. Without a hands-on demo, I am still not sure if I could put the concepts into practice. Using Git was the easiest part of the course since I was already familiar with GitHub and Atom.
